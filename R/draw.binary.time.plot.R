##' Plots a binary time summary plot using ggplot2
##'
##' Takes a data.table generated by generate.binary.time.summary.dt(), and plots
##' using ggplot2, with time on the x axis, and percentage on the y-axis.
##'
##' @title
##' @param binary.time.summary.dt Proportion and CIs over time calculated by
##'   generate.binary.time.summary.dt()
##' @param minor.date.breaks Minor date breaks on x axis, see
##'   ggplot2::scale_x_date() (Default: "3 months")
##' @param major.date.breaks Major date breaks on x axis, see
##'   ggplot2::scale_x_date() (Default: "1 year")
##' @param date.label.format Format of labels on x axis (Default: "%Y)
##' @param y.breaks Percentage breaks on the y axis (Default: ggplot2 default)
##' @param x.lims Two element vector with minimum maximum time (Default: ggplot2
##'   default)
##' @param y.lims Two element vector with minimum maximum percentage (Default:
##'   c(0, NA))
##' @param x.title Title of the x axis (Default: 'Year')
##' @param y.title Title of the y axis, not really needed for multiple lines as
##'   they're labeled in the legend (Default: NULL)
##' @param legend.title Title of the legend for different lines, won't be
##'   present with just one measure (Default: 'Measure')
##' @param legend.labels.rename Named vector with which to rename lines legend.
##'   Names should be levels in binary.time.summary.dt, with values as new name
##'   (Default: c())
##' @param draw.ci Draw confidence intervals around lines (Default: FALSE)
##' @param draw.smooth.line Draw a smooth best-fit line using loess (Default:
##'   FALSE)
##' @param smooth.span Span of the best-fit line, higher is smoother, see
##'   ggplot2::stat_smooth() (Default: FALSE)
##' @param period.rect.plot A plot generated by draw.period.rect.plot with
##'   geom_rect objects highlighting certain periods (Default: NULL)
##' @return ggplot2 object with plot
draw.binary.time.plot <- function(binary.time.summary.dt, 
                                  minor.date.breaks = "3 months",
                                  major.date.breaks = "1 year",
                                  date.label.format = "%Y", 
                                  y.breaks = waiver(), 
                                  x.lims = NULL, 
                                  y.lims = c(0,NA),
                                  x.title = "Year", 
                                  y.title = NULL,
                                  legend.title = "Measure",
                                  legend.labels.rename = c(), 
                                  draw.ci = FALSE,
                                  draw.smooth.line = FALSE, 
                                  smooth.span = 1,
                                  period.rect.plot = NULL) {

  ribbon.alpha = 0.25
  
  p = ggplot()
  
  # Add rects indicating periods if applicable.
  if (!is.null(period.rect.plot)) {
    p = p + period.rect.plot
  }
  
  # Draw a ribbon with CIs if requested, or if not unrequested and the data exist.
  if (draw.ci == TRUE | is.na(draw.ci & 'lwr.ci' %in% names(binary.time.summary.dt))) {
    p = p +
      geom_ribbon(data = binary.time.summary.dt,
                  aes(x = time,
                      ymin = lwr.ci,
                      ymax = upr.ci,
                      group = measure,
                      linetype = measure),
                  colour = rgb(0,0,0,0.25)[1],
                  alpha = .2)
  }
  
  # Relabel factors if requested.
  legend.levels = binary.time.summary.dt[,levels(measure)]
  legend.labels = legend.levels
  if (length(legend.labels.rename) > 0) {
    names(legend.labels) = legend.labels
    legend.labels[names(legend.labels.rename)] = legend.labels.rename
  }
  
  p = p + 
    # Line of proportions
    geom_line(data = binary.time.summary.dt,
              aes(x = time,
                  y = proportion,
                  group = measure,
                  linetype = measure)) +
    # Also plot points
    geom_point(data = binary.time.summary.dt,
               aes(x = time,
                   y = proportion,
                   group = measure,
                   shape = measure)) +
    # Percentage y axis
    scale_y_continuous(name = y.title,
                       labels = scales::percent,
                       breaks = y.breaks,
                       limits = y.lims) +
    
    # Date x axis
    scale_x_date(name = x.title,
                 date_labels = date.label.format,
                 date_breaks = major.date.breaks,
                 date_minor_breaks = minor.date.breaks,
                 limits = x.lims) +
    theme(axis.text.x = element_text(angle = 90,
                                     vjust = 0.5,
                                     hjust=1)) +
    
    # Line legend scales
    scale_linetype_discrete(name = str_wrap(legend.title,20),
                            breaks = legend.levels,
                            labels = legend.labels) +
    scale_shape_discrete(name = str_wrap(legend.title,20),
                         breaks = legend.levels,
                         labels = legend.labels) +
    
    # Title for period rect if present.
    scale_fill_discrete(name = 'Period')
  
  # Draw smooth line
  if (draw.smooth.line) {
    p = p +
      geom_line(data = binary.time.summary.dt,
                stat = 'smooth',
                method = 'loess',
                formula = y ~ x,
                span = smooth.span,
                aes(x = time,
                    y = proportion,
                    group = measure,
                    linetype = measure),
                size = 1,
                alpha = 0.4) +
      geom_smooth(data = binary.time.summary.dt,
                  stat = 'smooth',
                  method = 'loess',
                  formula = y ~ x,
                  span = smooth.span,
                  aes(x = time,
                      y = proportion,
                      group = measure),
                  linetype = 0,
                  alpha = ribbon.alpha)
  }
  
  # Remove legend for lines if only one level.
  if (length(binary.time.summary.dt[,unique(measure)]) == 1) {
    p = p +
      guides(linetype = FALSE,
             shape = FALSE)
  }
  
  
  
  return(p)

}
